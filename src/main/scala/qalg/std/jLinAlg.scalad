package com.faacets.qalg
package std

import scala.{specialized => sp}

import scala.reflect.{classTag, ClassTag}

import spire.algebra._
import spire.math.Rational
import spire.std.double._

import org.jlinalg.{Vector => JVector, Matrix => JMatrix, IRingElement, IRingElementFactory}
import org.jlinalg.rational.{Rational => JRational}
import org.jlinalg.doublewrapper.DoubleWrapper
import org.jlinalg.operator.MonadicOperator

import algebra._

trait JLinAlgBase[@sp(Double, Long) A, J <: IRingElement[J]] extends Any {
  implicit def jClassTag: ClassTag[J]
  implicit def eqA: Eq[A]
  implicit def scalar: AdditiveMonoid[A]
  def toJ(a: A): J
  def fromJ(j: J): A
}

class NegateOperator[RE <: IRingElement[RE]] extends MonadicOperator[RE] {
  def apply(re: RE): RE = re.negate
}

trait JLinAlgVec[@sp(Double, Long) A, J <: IRingElement[J]] extends Any
    with JLinAlgBase[A, J]
    with VecInField[JVector[J], A]
    with VecMutable[JVector[J], A] { self =>
  type V = JVector[J]
  def V: Vec[V, A] = self
  def apply(v: V, k: Int): A = fromJ(v.getEntry(k + 1))
  def update(v: V, k: Int, a: A): Unit = { v.set(k + 1, toJ(a)) }
  def length(v: V): Int = v.length
  def from(v: FunV[A]): V = new V(Array.tabulate[J](v.len)(k => toJ(v.f(k))))
  override def plus(x: V, y: V): V = x.add(y)
  override def minus(x: V, y: V): V = x.subtract(y)
  override def negate(v: V): V = v.apply(new NegateOperator[J])
  override def timesl(a: A, v: V): V = v.multiply(toJ(a))
}

trait JLinAlgMatVec[@sp(Double, Long) A, J <: IRingElement[J]] extends Any
    with JLinAlgBase[A, J]
    with MatVecInField[JMatrix[J], JVector[J], A]
    with MatVecMutable[JMatrix[J], JVector[J], A] { self =>
  type M = JMatrix[J]
  type V = JVector[J]
  implicit def M: MatInField[M, A] with MatMutable[M, A] = self
  implicit def V: VecInField[V, A] with VecMutable[V, A]
  def nRows(m: M): Int = m.getRows
  def nCols(m: M): Int = m.getCols
  def apply(m: M, r: Int, c: Int): A = fromJ(m.get(r + 1, c + 1))
  def update(m: M, r: Int, c: Int, a: A): Unit = { m.set(r + 1, c + 1, toJ(a)) }
  def from(m: FunM[A]): M = new M(Array.tabulate[J](m.nR, m.nC)( (r, c) => toJ(m.f(r, c))))
  override def plus(x: M, y: M): M = x.add(y)
  override def minus(x: M, y: M): M = x.subtract(y)
  override def negate(m: M): M = m.apply(new NegateOperator[J])
  override def timesl(a: A, m: M): M = m.multiply(toJ(a))
  override def times(x: M, y: M): M = x.multiply(y)
  override def timesl2(v: V, m: M): V = v.multiply(m)
  override def timesr2(m: M, v: V): V = m.multiply(v)
  override def t(m: M): M = m.transpose
}

trait JLinAlgInstances {
  implicit val JLinAlgRationalMV = new JLinAlgMatVec[Rational, JRational] with JLinAlgMat: JLinAlgVec[Rational, JRational] = new JLinAlgRationalVec
  implicit val JLinAlgDoubleVec: JLinAlgVec[Double, DoubleWrapper] = new JLinAlgDoubleVec
  implicit val JLinAlgRationalMat: JLinAlgMat[Rational, JRational] = new JLinAlgRationalMat
  implicit val JLinAlgDoubleMat: JLinAlgMat[Double, DoubleWrapper] = new JLinAlgDoubleMat
}
