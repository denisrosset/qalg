package com.faacets.qalg
package algos

import scala.{specialized => sp}

import spire.algebra._
import spire.math._
import spire.syntax.signed._
import spire.syntax.order._
import spire.syntax.vectorSpace._
import spire.syntax.field._
import spire.syntax.cfor._

import algebra._
import syntax.all._

trait LU {
  // assumes matrix non singular
  def luDecomposition[MA, VA, @sp(Double, Long) A: Field: Signed: Order](ma: MA)(implicit MA: MatInField[MA, A] with MatMutable[MA, A] with MatBuilder[MA, A] with MatVecSlice[MA, VA, A], VA: VecInField[VA, A]): (MA, Array[Int], Int) = {
    val rows = matSyntax(ma).nRows
    val cols = ma.nCols
    require(rows == cols)
    var flag = 1 // changes sign with each row interchange
    val n = rows
    val order: Array[Int] = Array(0 until n:_*) // establish initial ordering in order vector
    val a: MA = MA.from(ma.view(::, ::))
    /* Find pivot element
     * 
     * The function pivot finds the largest element for a pivot in "jcol"
     * of Matrix "a", performs interchanges of the appropriate
     * rows in "a", and also interchanges the corresponding elements in
     * the order vector.
     *
     * using    a      -  n by n Matrix of coefficients
     * using    order  - integer vector to hold row ordering
     * @param   jcol   - column of "a" being searched for pivot element
     *
     */
    def pivot(jcol: Int): Boolean = {
      var ipvt = jcol
      var big = a(ipvt, ipvt).abs
      // Find biggest element on or below diagonal. This will be the pivot row.
      for (i <- ipvt + 1 until n) {
        val anext = a(i, jcol).abs
        if (anext > big) {
          big = anext
          ipvt = i
        }
      }
      if (big == 0) throw new IllegalArgumentException("LU decomposition is implemented for now only for non-singular matrices.")
      assert(big != 0) // otherwise Matrix is singular
      // Interchange pivot row (ipvt) with current row (jcol).
      if (ipvt == jcol) false
      else {
        val row = a(jcol, ::)
        a(jcol, ::) = a(ipvt, ::)
        a(ipvt, ::) = row
        val tmp: Int = order(jcol)
        order(jcol) = order(ipvt)
        order(ipvt) = tmp
        true
      }
    }

    /* do pivoting for first column and check for singularity */
    if (pivot(0)) flag = -flag
    val diag0 = Rational.one/a(0,0)
    for (i <- 1 until n)
      a(0,i) *= diag0

    //  Now complete the computing of L and U elements.
    //  The general plan is to compute a column of L's, then
    //  call pivot to interchange rows, and then compute
    //  a row of U's.

    var nm1 = n - 1

    for (j <- 1 until nm1) {
      /* column of L's */
      for (i <- j until n) {
	var sum = Rational.zero
        for (k <- 0 until j)
          sum += a(i,k) * a(k,j)
        a(i,j) -= sum
      }
      /* pivot, and check for singularity */
      if (pivot(j)) flag = -flag
      /* row of U's */
      val diag = Rational.one/a(j,j)
      for (k <- j + 1 until n) {
        var sum = Rational.zero
        for (i <- 0 until j)
          sum += a(j,i) * a(i,k)
        a(j,k) = (a(j,k) - sum) * diag
      }
    }

    /* still need to get last element in L Matrix */

    var suml = Rational.zero
    for (k <- 0 until nm1)
      suml += a(nm1,k) * a(k,nm1)
    a(nm1,nm1) -= suml
    (a, order, flag)
  }
}
