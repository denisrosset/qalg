package com.faacets
package qalg

import spire.algebra.{Field, Monoid, Ring, VectorSpace}
import spire.math.Rational
import spire.syntax.cfor._
import spire.syntax.innerProductSpace._

/** Base trait for mutable or immutable matrices. */
abstract class QMatrixBase[M <: QMatrixBase[M, V], V <: QVectorBase[V, M]] extends GenQMatrix with QTensorBase[M] {
  lhs: M =>

  def isIntegerMatrix: Boolean = {
    cfor(0)(_ < rows, _ + 1) { r =>
      cfor(0)(_ < cols, _ + 1) { c =>
        if (this(r, c).denominator != 1)
          return false
      }
    }
    true
  }

  def isIdentity: Boolean = {
    if (rows != cols) return false
    cfor(0)(_ < rows, _ + 1) { r =>
      cfor(0)(_ < cols, _ + 1) { c =>
        if ((r == c && this(r,c) != Rational.one) || (r != c && this(r,c) != Rational.zero))
          return false
      }
    }
    return true
  }

  def solve(b: V): V = {
    val (lu, order, flag) = luDecomposition
    var n = rows
    // rearrange the elements of the b vector, hold them into x
    val x = mutable.QVector.tabulate(n)( i => b(order(i)) )
    if( (0 until n).exists( i => lu(i,i) == 0 ) )
      throw new IllegalArgumentException("Coefficient matrix is singular")
    // do forward substitution, replacing x vector
    x(0) /= lu(0,0)
    for (i <- 1 until n) {
      var sum = Rational.zero
      for (j <- 0 until i) sum += lu(i,j) * x(j)
      x(i) = (x(i) - sum)/lu(i,i)
    }
    // now get the solution vector, x(n-1) is already done
    for (i <- n - 2 to 0 by -1) {
      var sum = Rational.zero
      for (j <- i + 1 until n) sum += lu(i,j) * x(j)
      x(i) -= sum
    }
    vectorFactory.unsafeBuild(x)
  }

  def rank = rref._2.length

  /** Return reduced row-echelon form of matrix.
    */
  def rref: (M, List[Int]) = {
    val a = toMutable
    var used = List.empty[Int]
    var r = 0
    for (c <- 0 until cols) {
      if (r < rows) {
        val (m, pivot) = (r until rows).map( i => (a(i,c).abs, i) ).max
        if (m != 0) { // if m is zero, skip the column c
          used = c :: used // keep track of bound variables

          // swap current row and pivot row
          val tmp = a(pivot, c until cols)
          a(pivot, c until cols) = a(r, c until cols)
          a(r, c until cols) = tmp
          // normalize pivot row
          val f = a(r, c)
          for (c1 <- c until cols)
            a(r, c1) = a(r, c1) / f
          // eliminate current column
          for (ridx <- 0 until rows) {
            if (ridx != r)
              a(ridx, c until cols) = a(ridx, c until cols) - (a(r, c until cols) :* a(ridx, c))
          }
          r += 1
        }
      }
    }
    (factory.unsafeBuild(a), used)
  }

  def isTimesIdentity: Boolean = {
    if (rows != cols) return false
    val ct = this(0,0)
    cfor(0)(_ < rows, _ + 1) { r =>
      cfor(0)(_ < cols, _ + 1) { c =>
        if ((r == c && this(r,c) != ct) || (r != c && this(r,c) != Rational.zero))
          return false
      }
    }
    return true
  }

  /** Performs the Gram-Schmidt process to orthogonalize the rows of matrix
    * M. */
  def integerOrthogonalized: M = {
    val res = mutable.QMatrix(this)
    for (i <- 0 until rows-1) {
      val v = res(i, ::).toQVector
      for (j <- i+1 until rows) {
        val r = res(j, ::).toQVector
        res(j, ::) = ( ((v dot v) *: r) - ((v dot r) *: v) ).withPrimes._1
      }
    }
    factory.unsafeBuild(res)
  }
}

